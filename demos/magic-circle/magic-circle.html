<!doctype html>

<html>
	<head>
		<title>Page Title</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="initial-scale=1.0">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.8/p5.js"></script>
		<script>
			let objects = []; // objects to animate
			let count = 0;
		  	let time = 0, lastTime = 0;
			function setup() {
				createCanvas(720, 400);
				stroke(0);
				noFill()
				frameRate(60);
				background(255);
				
				// demo settings
				const TRANSPARENT = color(0, 0);
				const BLACK = color(0, 255);
				let circleAppearDuration = 2000;
				let originVector = createVector(width/2, height/2);
				
				// keep track of animations/objects being added
				let animationStart = 1000;
				let circleSize = 200;
				
				// add a circle to draw
				objects.push(
					new Arc({
						center: originVector,
						radius: circleSize / 2,
						startAngle: 0,
						endAngle: 0
					}).animate("color", TRANSPARENT, BLACK, circleAppearDuration, animationStart)
						 .animate("endAngle", 0, TWO_PI, circleAppearDuration, animationStart)
				)
				
				// add some lines that surround the circle
				let numLines = 20;
				let lineLength = 30;
				
				objects.push(
					new RadiatingLineCircle({
						center: originVector,
						radius: circleSize / 2,
						numLines: numLines,
						lineLength: lineLength,
						color: TRANSPARENT,
						circleDuration: circleAppearDuration,
						extendDuration: 1000,
						delay: animationStart
					})
				);
				animationStart += circleAppearDuration * 2
				
				objects.push(
					new DrawingStar({
						center: originVector,
						radius: circleSize / 2,
						numPoints: 5,
						color: BLACK,
						duration: 1500,
						delay: animationStart
					})
				);
				
				
			}
			
			class Animatable {
				constructor() {
					this.animations = [];
				}
				
				animate(propName, first, last, duration, delay) {
					// TODO error checking
					this.animations.push({
						prop: propName,
						first: first, // black, no opacity
						last: last, // black, full opacity
						duration: duration || 1000,
						delay: delay || 0,
						progress: 0
					});
					return this;
				}
				
				// advance by `time` milliseconds
				next(time) {
					for (let j = 0; j < this.animations.length; j++) {
						let anim = this.animations[j];

						// add the current time to the progress of animation
						anim.progress = min(anim.progress + time, anim.duration + (anim.delay || 0));
						// fix progress ratio between 0 and 1
						let progressRatio = constrain((anim.progress - (anim.delay || 0)) / anim.duration, 0, 1);
						
						// update the actual property
						if (anim.progress < anim.delay) {
							// skip when the animation hasn't started
							continue;
						}
						
						if (isVector(this[anim.prop])) {
							// is a vector, use vector lerp
							this[anim.prop] = p5.Vector.lerp(anim.first, anim.last, progressRatio);	
						} else if (isColor(this[anim.prop])) {
							this[anim.prop] = lerpColor(anim.first, anim.last, progressRatio);	
						} else {
							// is scalar, use scalar lerp
							this[anim.prop] = lerp(anim.first, anim.last, progressRatio);	
						}
						
						// TODO how to remove animations that are done?
					}
				}
			}
			
			class Arc extends Animatable {
				constructor(props) {
					super(props);
					this.color = color(9, 0);
					
					// assign properties to `this`
					for (let prop in props) {
						this[prop] = props[prop];
					}
				}
			
				draw() {
					stroke(this.color);
					arc(this.center.x, this.center.y, this.radius * 2, this.radius * 2, this.startAngle, this.endAngle);
				}
			}
			
			class Line extends Animatable {
				constructor(props) {
					super(props);
					this.color = color(9, 0);
					
					// assign properties to `this`
					for (let prop in props) {
						this[prop] = props[prop];
					}
				}
				
				next(time) {
					super.next(time);
				}
				
				draw() {
					stroke(this.color);
					line(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
				}
			}
			
			class RadiatingLineCircle extends Animatable {
				// TODO document valid properties
				constructor(props) {
					super(props);
					this.color = color(9, 0);
					this.lines = [];
					
					// assign properties to `this`
					for (let prop in props) {
						this[prop] = props[prop];
					}
					
					// initialize lines
					for (let i = 0; i < this.numLines; i++) {
						// decide where the initial and final point should be
						// the initial point starts on the circle
						// the outer point grows perpendicularly to the circle's tangent

						let innerPoint = p5.Vector.add(
							this.center,
							p5.Vector.fromAngle(TWO_PI * i / this.numLines).setMag(this.radius)
						);
						let outerPoint = p5.Vector.add(
							innerPoint,
							p5.Vector.fromAngle(TWO_PI * i / this.numLines).setMag(this.lineLength)
						);

						// add line
						let l = new Line({
							p1: innerPoint, 
							p2: innerPoint
						}).animate(
							"color", 
						   color(0, 255 * i / this.numLines), 
						   color(0, 255), 
						   (this.numLines - i - 1) / this.numLines * this.circleDuration, 
						   i / this.numLines * this.circleDuration + this.delay
						).animate(
							"p2", 
							innerPoint,
							outerPoint,
							this.extendDuration,
							i / this.numLines * this.circleDuration + this.delay
						);
						this.lines.push(l);
					}
				}
				
				next(time) {
					super.next(time);
					for (let i = 0; i < this.lines.length; i++) {
						this.lines[i].next(time);
					}
				}
				
				draw() {
					stroke(this.color);
					for (let i = 0; i < this.lines.length; i++) {
						this.lines[i].draw();
					}
				}
			}
			
			class DrawingStar extends Animatable {
				constructor(props) {
					super(props);
					this.color = color(9, 0);
					this.lines = [];
					
					// assign properties to `this`
					for (let prop in props) {
						this[prop] = props[prop];
					}
					
					// add each line animation one by one
					let n = 0; // number of lines drawn so far
					let currentVertex = 0; // current vertex
					while (n < this.numPoints) {
						let nextVertex = (currentVertex + Math.floor(this.numPoints / 2)) % this.numPoints;
						
						let p_i = p5.Vector.add(
							this.center,
							p5.Vector.fromAngle(TWO_PI * currentVertex / this.numPoints).setMag(this.radius)
						);
						let p_next = p5.Vector.add(
							this.center,
							p5.Vector.fromAngle(TWO_PI * nextVertex / this.numPoints).setMag(this.radius)
						);

						// add line
						let l = new Line({
							p1: p_i, 
							p2: p_i,
							color: this.color
						}).animate(
							"p2",
							p_i,
							p_next,
							this.duration / this.numPoints,
							this.delay + n * this.duration / this.numPoints
						);
						this.lines.push(l);
						
						currentVertex = nextVertex;
						n++;
					}
				}
				
				next(time) {
					super.next(time);
					for (let i = 0; i < this.lines.length; i++) {
						this.lines[i].next(time);
					}
				}
				
				draw() {
					stroke(this.color);
					for (let i = 0; i < this.lines.length; i++) {
						this.lines[i].draw();
					}
				}
			}
			
			function isVector(obj) {
				return obj.hasOwnProperty("x") && obj.hasOwnProperty("y");
			}
			
			function isColor(obj) {
				return obj instanceof p5.Color;
			}
			
			function draw() { 
				background(255);
				lastTime = time;
				time = millis();
				let diff = time - lastTime;
				
				// update properties
				for (let i = 0; i < objects.length; i++) {
					objects[i].next(diff);
				}
				
				// drawing
				for (let i = 0; i < objects.length; i++) {
					objects[i].draw();
				}
			  
				// limit the amount of time the animation runs
				count++;
				if (count > 2000) {
					noLoop();
					console.log("finished animation");
				}
			}
			
		</script>
	</head>

	<body>

	</body>
</html>